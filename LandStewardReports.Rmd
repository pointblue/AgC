---
title: |
  <img src="ReportImages/PBLogo.png" alt="My Image" style="width: 300px;">  
  <img src="ReportImages/AgCLogo.png" alt="My Image" style="width: 500px;">  
  Land Steward Report
author: "Avalon Cook"
date: "`r format(Sys.Date(), '%B %d %Y')`"
output:
  bookdown::html_document2:
    number_sections: FALSE
    toc: true
    toc_float: true
    toc_depth: 3  # Include up to level 2 headers
    self_contained: true
dev: png
params:
  project_name: MERC
---
```{r Setup, echo=FALSE, message=FALSE, warning=FALSE, error=FALSE, results='hide'}

#Created by: Avalon Cook
#Created: 20231214
#Updated: 20241126 (by AC)

knitr::opts_chunk$set(
	echo = FALSE,
	message = FALSE,
	warning = FALSE, 
	error=FALSE)

setwd("Z:/Soils Team/AgC")
data_path<-("Z:/Soils Team/AgC Data/Master Datasheets")

#renv::restore() #CHECK add renv to this rproj?

library(knitr)
library(sf)
library(leaflet)
library(googlesheets4)
library(dplyr)
library(kableExtra)
library(tidyr)
library(ggplot2)
library(ggh4x)
library(stringr)
library(soiltexture)
library(leafpop)
library(gridExtra)
library(grid)

gs4_auth_configure(api_key = 'AIzaSyBEULjhG3_r_ZX6F7ZKDEUQ5yOgUbKVh6o') #this auth key is linked to Avalon's account and should prevent from the user needing to manually authorize each time, like in the line below

#gs4_auth() #this line will initiate a prompt in your console and take you to your browser to approve access to your Google Drive
```
```{r, project.summary}
######################NEW#######################
#pulling in spatial data
spatial_path <- "Z:/Soils Team/AgC Data/Raw Data/Spatial Data/ZippedShapefiles" #define the location of ACTION GIS data

border_pattern <- paste0(params$project_name, "_border.zip") #specify the pattern of the border file
borderzip_file <- list.files(
  path = spatial_path,
  pattern = border_pattern,
  recursive = TRUE,
  full.names = TRUE) # Search for the matching file, recursively
temp_folder1 <- tempfile() #create a temp directory where the shapefile can be unzipped
unzip(borderzip_file, exdir = temp_folder1)
border_file<-list.files(temp_folder1, pattern = "\\_border.shp$", full.names = TRUE)
border<- read_sf(border_file) #read in project polygon

#repeat for sampling points
points_pattern <- paste0(params$project_name, "_pointsfinal.zip") 
pointszip_file <- list.files(
  path = spatial_path,
  pattern = points_pattern,
  recursive = TRUE,
  full.names = TRUE) 
temp_folder2 <- tempfile() 
unzip(pointszip_file, exdir = temp_folder2)
points_file<-list.files(temp_folder2, pattern = "\\_pointsfinal.shp$", full.names = TRUE)
points<- read_sf(points_file) 
######################NEW#######################


###################NEW reading in master datasheets###################
#Reading in master datasheets and filtering by project of interest
list_dfs_field<-list.files(file.path(data_path, "FieldLevel", ""), pattern = "\\.csv$", full.names = TRUE)
FieldLevel<-list_dfs_field[which.max(as.Date(gsub("\\D","", list_dfs_field), format = "%Y%m%d"))]%>%
  read.csv()%>%
  filter(project_name == params$project_name)

list_dfs_point<-list.files(file.path(data_path, "PointLevel", ""), pattern = "\\.csv$", full.names = TRUE)
PointLevel<-list_dfs_point[which.max(as.Date(gsub("\\D","", list_dfs_point), format = "%Y%m%d"))]%>%
  read.csv()%>%
  filter(project_id == params$project_name)

list_dfs_design<-list.files(file.path(data_path, "ProjectDesign", ""), pattern = "\\.csv$", full.names = TRUE)
ProjectDesign<-list_dfs_design[which.max(as.Date(gsub("\\D","", list_dfs_design), format = "%Y%m%d"))]%>%
  read.csv()%>%
  filter(project_id == params$project_name)

#add project design datasheet, then assign all the variables created above

format_practice_string <- function(x) { #this function reformats the string of conservation practices to be more readable (GPT)
  n_commas <- stringr::str_count(x, ",")
  if (n_commas == 1) {
    # Replace the comma with " &"
    sub(",", " &", x)
  } else if (n_commas >= 2) {
    # Replace only the last comma with ", and"
    sub(",([^,]*)$", ", and\\1", x)
  } else {
    # No commas, return as-is
    x
  }
}

#Establishing variables for report structure
proj.protocol <- FieldLevel$rangec_cropc[1]
proj.inscore <- ProjectDesign$inference_score[1]
proj.propertyname <- ProjectDesign$ranch_name[1]
proj.implementationyear <- ProjectDesign$proj_practice_year[1]
proj.practicetype <- format_practice_string(ProjectDesign$conservation_practice[1])
proj.title <- paste(proj.propertyname, proj.implementationyear, proj.practicetype, sep=" ")
############################################################################

```

# `r proj.title` {.unlisted .unnumbered}

## Background: ACTION for CSA and Ag-C
Thank you for participating in the Agricultural Carbon Monitoring Program. Ag-C was developed to help practitioners conduct transparent, fit-for-purpose monitoring of aboveground and belowground carbon in response to common conservation practices. At the same time that it supports management efforts at the farm scale, Ag-C is designed to evaluate management effects on carbon at regional scales when data is aggregated network-wide in the secure Point Blue Science Cloud. The collected information, from management history to field measurements, will support greater understanding of commonly incentivized practice impact on ecosystem carbon. 

The Agricultural Carbon ("Ag-C") Monitoring Program was developed by the Soils Team at Point Blue Conservation Science to help practitioners conduct transparent, fit-for-purpose monitoring of carbon dynamics in response to rangeland and cropland management. This report reviews the initial measurement for the baseline carbon indicators measured at your agricultural site. Continued use of the Ag-C protocols over time can assess the impact of your conservation effort. 

This report reviews monitoring efforts to date for the carbon indicators measured at your agricultural site. Continued use of the Ag-C protocols over time can assess the long-term impact of your conservation effort. Find additional information and funding updates for continued use of the Ag-C Monitoring Program on [our landing page](https://www.pointblue.org/ag-c/). 

## Project Design
The Ag-C program offers a flexible approach to designing a monitoring program. This includes the option to select carbon indicators of interest, tailor methods to your goals and resources, and match project design elements to your context. Ag-C is made of two major components: Range-C to accommodate monitoring in rangeland systems and Crop-C to accommodate monitoring in cropland systems. At your site, `r proj.protocol` was used as the guiding framework for developing a monitoring plan.^[To learn more about designing a monitoring program with `r proj.protocol`, consult the [`r proj.protocol` Handbook](`r ifelse(proj.protocol=='Range-C', 'https://www.pointblue.org/?sdm_process_download=1&download_id=19991', 'https://www.pointblue.org/?sdm_process_download=1&download_id=20943')`)]

To support interpretability and comparability, `r proj.protocol` assigns each monitoring project an “inference score” which reflects how decisions made in the project design process impact the overall rigor and reliability of the resulting data. Inference scores range from 40 to 100, where a higher score generally reflects greater confidence in the project's findings or a more holistic characterization of carbon dynamics in the study site. Nonetheless, all `r proj.protocol` projects represent a minimum standard of rigor and reliability. 

The monitoring plan developed for the `r paste0(proj.implementationyear, " ", proj.practicetype)` practice at `r proj.propertyname ` results in a `r proj.protocol` inference score of `r proj.inscore`.
```{r, echo=FALSE, fig.height=3, fig.align='center', fig.cap="A visual representation of how different project design decisions impact the final inference score"}
#CHECK new graphic necessary?
#not including this for now because we need to make an updated version for crop-c; the one i currently have is range-c specific
#Refer to the graphic below for a visual representation of how different project design decisions contribute to the inference score. 
#knitr::include_graphics("InferenceScore.png") # CHANGE THIS TO ACCOMODATE BOTH PROTOCOLS
```

### Carbon indicators
The following table includes carbon indicators that were included in this monitoring project and their corresponding acronyms that will be used in the following tables, graphs, and maps. A description of each indicator and reported units are provided. 
```{r, updated}
proj.indicator.db<-read.csv("ReportRef/indicator_descriptions.csv", check.names=FALSE)#read in the indicator descriptions reference sheet

proj.indicators<-proj.indicator.db$Acronym

proj.indicator.table<-proj.indicator.db%>% 
  rowwise() %>%
  filter(!all(is.na(PointLevel[[CheckCol]])))%>%
  filter(!Acronym %in% c("Sand", "Silt", "Clay"))


ind.table.kbl<-proj.indicator.table%>%select(Indicator, Acronym, Description, `Final units`)

Table1<-kbl(ind.table.kbl,
      caption= "Description of carbon indicators",
      col.names = gsub("[.]", " ", x=names(ind.table.kbl)), 
      row.names = FALSE,
      vline = "|",
      linesep = "\\addlinespace",
      align= c('llll'))

Table1 %>% 
  kable_styling(position='center', full_width = T) %>%
  column_spec(1, width="1.25in")%>%
  column_spec(2, width="0.5in")%>%
  column_spec(3, width="2.5in")%>%
  column_spec(4, width="1.75in")%>%
  row_spec(0, bold=TRUE)
```

### Spatial design
The interactive map below shows the boundaries of the study area for monitoring and how sampling points are distributed. 
```{r}
#spatial data was pulled in above. Use this chunk to render your map.

border <- st_transform(border, crs = 4326)
points <- st_transform(points, crs = 4326)
points$labels <- substr(points$name, nchar(points$name) - 1, nchar(points$name))

pal <- colorFactor(c("white","black"), c("T", "C"))

leaflet() %>%
  addProviderTiles(providers$Esri.WorldImagery) %>%
  addPolygons(data = st_zm(border),
              fillOpacity = 0,
              color = ~ pal(plot_type),
              opacity=1)%>%
     addLegend(
      pal = pal, 
      values = border$plot_type,
      title = "Plot Type",
      position = "bottomleft",
      labFormat = function(type, cuts, p) { 
      c("Treatment", "Control")[match(cuts, c("T", "C"))]
    })%>%
  addLabelOnlyMarkers(data=points,
                      label = points$labels, 
                      labelOptions = labelOptions(
                        noHide = TRUE, 
                        direction = "center",
                       offset = c(0, 0),
                      style = list(
                              "font-weight" = "bold", 
                              "padding" = "1px", 
                              "border-radius" = "4px"
                                                  )))


```
```{r Dynamic text generation 1, results='asis'}
for.legend<-as.data.frame(points)
for.legend<-arrange(for.legend, plot_type, labels)

#this section states which, if any, indicators were measured at every sampling point and removes them from the following legend table

for (column_name in proj.indicator.table$Acronym) {
  if (length(unique(for.legend[[column_name]])) == 1) {
    for.legend <- select(for.legend, -column_name)
  }
}

allpoints.list <- proj.indicator.table$CheckCol[
  proj.indicator.table$CheckCol %in% names(PointLevel) &    # must exist
    sapply(proj.indicator.table$CheckCol, function(col) all(!is.na(PointLevel[[col]])))
]

allpoints.table <- proj.indicator.table %>%
  filter(CheckCol %in% allpoints.list)

if (length(allpoints.list)>0){
cat("The following indicators were measured at every sampling point:", paste(allpoints.table$Indicator, collapse = ", "), "\n")}
```

```{r Dynamic text generation 2, results='asis'}
if (identical(allpoints.list, proj.indicator.table$CheckCol)==FALSE){
cat("Indicators that were only measured at some sampling points are listed in the table below.")}
```

```{r, indicator.legend}
#CHECK this system needs testing after being modified#
#the conditional format here makes sure the table is only generated if the projected included some indicators only measured at some sampling points
if (identical(allpoints.list, proj.indicator.table)==FALSE){
  legend.T <- list()
  legend.C <- list()
  
inds.for.legend <- proj.indicator.table$CheckCol[
  proj.indicator.table$CheckCol %in% names(PointLevel) &    # must exist
    sapply(proj.indicator.table$CheckCol, function(col) any(is.na(PointLevel[[col]])))
]  

  # List points monitored for each indicator in T and C plots
  for (column_name in inds.for.legend) {
    result <- paste(for.legend$labels[complete.cases(for.legend[[column_name]]) & for.legend[[column_name]] == 1 & for.legend$plot_type == "T"], collapse = ", ")
    legend.T[[column_name]] <- result
  }
  
  for (column_name in inds.for.legend) {
    result <- paste(for.legend$labels[complete.cases(for.legend[[column_name]]) & for.legend[[column_name]] == 1 & for.legend$plot_type == "C"], collapse = ", ")
    legend.C[[column_name]] <- result
  }
  
  # Turn it into a dataframe and render a table
  results_df <- data.frame(Column = names(legend.T), ResultT = unlist(legend.T), ResultC = unlist(legend.C), stringsAsFactors = FALSE)
  rownames(results_df) <- NULL
  colnames(results_df) <- c("Indicator", "Treatment points", "Control points")
  if (length(unique(for.legend$plot_type)) ==1 ){
    results_df<-select(results_df, -3)}
kbl(caption = "Indicators measured at a subset of sampling points", results_df, align='lccr') %>% kable_styling(position='center', full_width = F)
}
```
```{r, other spatial design elements}
if (ProjectDesign$composite==TRUE){
  cat("Each soil sample was composed of smaller composited samples to capture small-scale variability at each sampling point. ")
}

if (ProjectDesign$point_generation_method=="GIS"){
  cat("Sampling points were randomly selected within the monitoring boundary using mapping software and located in the field by GPS.")
}else{cat("Sampling points were randomly selected using the Range-C Point Selector tool and paced to in the field.")}

#CHECK add statement for stratification? 
```


### Other design elements
The Ag-C framework flexibly accommodates different project design approaches. For example, the most rigorous project would include baseline monitoring before the conservation practice is implemented, as well as parallel monitoring at an untreated control site into the future. Although not logistically possible for every project, these elements together provide highly interpretable results. 

```{r Dynamic text Baseline and Control, results='asis'}

if (ProjectDesign$control_baseline=="yes" & length(unique(border$plot_type))==2){cat(paste0("This ", proj.protocol, " project includes baseline monitoring before the conservation practice was implemented as well as parallel monitoring at an untreated control site."))}

if (ProjectDesign$control_baseline=="yes" & length(unique(border$plot_type))==1){cat(paste0("This ", proj.protocol, " project includes baseline monitoring before the conservation practice was implemented, but did not include parallel monitoring at an untreated control site."))}

if (ProjectDesign$control_baseline=="no" & length(unique(border$plot_type))==2){cat(paste0("This ", proj.protocol, " project includes parallel monitoring at an untreated control site, but did not capture baseline conditions before practice implementation."))}
  
if (ProjectDesign$control_baseline=="no" & length(unique(border$plot_type))==1){cat(paste0("This ", proj.protocol, " project did not capture baseline conditions before practice implementation and was not able to compare current conditions to an untreated control site. While we are still able to characterize current conditions now and into the future, the results will have limited interpretability for understanding the full scope of practice impact."))}

#Do some conversions for a statement about max depth and depth increments
depth.increments.no <- ProjectDesign$depth_increments
convert_depths <- function(x) {
  sapply(strsplit(x, "_"), function(parts) {
    nums <- as.numeric(parts)
    nums <- round(nums * 0.393701)
    paste(nums, collapse = "-")
  })
}
depths.inches<-unique(PointLevel$target_depth)%>%convert_depths
max.depth.inches <- max(as.numeric(sub(".*-", "", depths.inches)))

cat(paste0("Soil samples were taken to a target maximum depth of ", max.depth.inches, " inches. " ))

if (depth.increments.no>1){
  cat("Depth increments from ", depths.string[1], " inches and ", depths.string[2], " inches were analyzed separately. ")
  
  depth_sentence <- function(depths.string) {
  paste0(
    "Depth increments from ",
    paste(depths.string, collapse = ", "),
    " inches were analyzed separately."
  ) |>
    sub(", ([^,]*)$", " and \\1", x = _)
  }
  depth_sentence(depths.inches)
  
}

```

## Results

### All soil properties
The following table summarizes average values across the study area for all soil metric(s) included in your project. 
```{r Summarize non-stocks soil means}

#creating a vector of value names that match the names in PointLevel
if ("Tx" %in% proj.indicators==TRUE) {
  proj.indicators.SSC<-c(proj.indicator.table$CheckCol, "sand", "silt")
} else {proj.indicators.SSC <- proj.indicator.table$CheckCol}

#Calculating stocks on qualifying soil metrics
if ("bulk_density" %in% proj.indicators.SSC){
soil.stocks.inds <- c("total_c", "total_n", "org_c", "inorg_c", "maoc", "poc", "pon") #these are the columns that can be turned into stocks (CHECK hard coding these in for now. Not sure if there's a better solution)
for(col in intersect(proj.indicators.SSC, soil.stocks.inds)) {
  new_col <- paste0(col, "_stocks")  # new column name
  PointLevel[[new_col]] <- PointLevel[[col]]*PointLevel$bulk_density*PointLevel$e_depth*0.4461 #calculating stocks in US tons / acre (percent to decimal cancels out) 
}
proj.indicators.SSC<- c(proj.indicators.SSC, paste0(intersect(proj.indicators.SSC, soil.stocks.inds), "_stocks")) #add those new column names to my list of indicator columns
}

PointLevel<-PointLevel%>% 
  mutate(plot_type = substr(sample_id, 6, 6)) #CHECK! should be temporary (will get built into PointLevel)

Project.Means <- PointLevel %>%
                    dplyr::group_by(plot_type) %>%
                    dplyr::summarise(across(all_of(proj.indicators.SSC), \(x) mean(x, na.rm = TRUE))) #find the mean for each indicator grouped by plot

Means.Pivot<- Project.Means %>% pivot_longer(cols=all_of(proj.indicators.SSC), names_to ='Indicator') %>%
          pivot_wider(names_from = c("plot_type"), values_from = value)%>%#pivot so that indicators are row names and plot type and depth increment combinations are column names
           left_join(
    proj.indicator.table %>% select(CheckCol, UnitsTable),
    by = c("Indicator" = "CheckCol")
  ) %>%
  mutate(
    Units = case_when(
      Indicator %in% c("sand", "silt", "clay") ~ "%",           # special values
      str_ends(Indicator, "_stocks") ~ "tons/acre",             # ends with _stocks
      TRUE ~ UnitsTable                                          # default mapping
    )
  ) %>%
  select(-UnitsTable)%>%
  mutate(
    # remove _stocks for matching if present
    Indicator_base = str_remove(Indicator, "_stocks$")
  ) %>%
  left_join(
    proj.indicator.table %>% select(Acronym, CheckCol),
    by = c("Indicator_base" = "CheckCol")
  ) %>%
  mutate(
    Units = case_when(
      str_ends(Indicator, "_stocks") ~ "tons/acre",  # special case
      Indicator %in% c("sand", "silt", "clay") ~ "%", # special values
      TRUE ~ UnitsTable                                # default mapping
    )
  ) %>%
  select(-Indicator_base, -UnitsTable)
          

#
#soil.inds<- c("SOC", "MAOC", "POC", "SIC", "BD", 'pH', "Sand", "Silt", "Clay") #define which indicators should be included in the soils table

soil.units.lookup <- data.frame(
  Indicator = proj.indicator.table$CheckCol,
  Units = proj.indicator.table$UnitsTable
) #define indicator units



Soil.Means <- Means.Pivot[Means.Pivot$Indicator, ] %>% #subset the means table to only include soil indicators [REMOVED THE SUBSET:  %in% soil.inds]
              left_join(soil.units.lookup, by="Indicator") %>% #add a column for the units
              select(Indicator, Units, everything()) #reorder
```
```{r Calculating carbon stocks}
#This should only happen if SOC and BD are present

if (ProjectTracker$Roadmap != "low"){

#Calculating SOC stocks
if ("BD" %in% proj.indicators == TRUE){
PointData.proj$SOC_stocks_g.cm2<-PointData.proj$BD * (PointData.proj$SOC*0.01) * (30) #get soc stocks in g/cm2 to specified depth
PointData.proj$SOC_stocks_tons.acre <- PointData.proj$SOC_stocks_g.cm2 *40470000/1000000 #convert to tons/acre to specified depth

SOC_stocks_summary<-PointData.proj %>%
  group_by(plot_typee) %>%
  summarise(
    indicator = "SOC",
    mean = mean(SOC_stocks_tons.acre, na.rm = TRUE),
    se = sd(SOC_stocks_tons.acre, na.rm = TRUE) / sqrt(n()),) %>%
  rename(plot=plot_typee)%>%
  select(indicator, mean, se, plot)


PointData.proj$SIC_stocks_g.cm2<-PointData.proj$BD * (PointData.proj$SIC*0.01) * (30) #get soc stocks in g/cm2 to specified depth
PointData.proj$SIC_stocks_tons.acre <- PointData.proj$SIC_stocks_g.cm2 *40470000/1000000 #convert to tons/acre to specified depth

SIC_stocks_summary<-PointData.proj %>%
  group_by(plot_typee) %>%
  summarise(
    indicator = "SIC",
    mean = mean(SIC_stocks_tons.acre, na.rm = TRUE),
    se = sd(SIC_stocks_tons.acre, na.rm = TRUE) / sqrt(n()),) %>%
  rename(plot=plot_typee)%>%
  select(indicator, mean, se, plot)

  
}

if (all(c("BD", "MAOC") %in% proj.indicators)==TRUE) {
  PointData.proj$MAOC_stocks_g.cm2<-PointData.proj$BD * (PointData.proj$MAOC*0.01) * (30) #get soc stocks in g/cm2 to specified depth
PointData.proj$MAOC_stocks_tons.acre <- PointData.proj$MAOC_stocks_g.cm2*40470000/1000000 #convert to tons/acre to specified depth

MAOC_stocks_summary<-PointData.proj %>%
  group_by(plot_typee) %>%
  summarise(
    indicator = "MAOC",
    mean = mean(MAOC_stocks_tons.acre, na.rm = TRUE),
    se = sd(MAOC_stocks_tons.acre, na.rm = TRUE) / sqrt(n()),) %>%
  rename(plot=plot_typee)%>%
  select(indicator, mean, se, plot)
}

if (all(c("BD", "POC") %in% proj.indicators)==TRUE) {
  PointData.proj$POC_stocks_g.cm2<-PointData.proj$BD * (PointData.proj$POC*0.01) * (30) #get soc stocks in g/cm2 to specified depth
PointData.proj$POC_stocks_tons.acre <- PointData.proj$POC_stocks_g.cm2 *40470000/1000000 #convert to tons/acre to specified depth

POC_stocks_summary<-PointData.proj %>%
  group_by(plot_typee) %>%
  summarise(
    indicator = "POC",
    mean = mean(POC_stocks_tons.acre, na.rm = TRUE),
    se = sd(POC_stocks_tons.acre, na.rm = TRUE) / sqrt(n()),) %>%
  rename(plot=plot_typee)%>%
  select(indicator, mean, se, plot)
}

####bind all the summaries together into one table

#list all the indicators that can be reported as stocks
stock_inds <- c("SOC", "SIC", "MAOC", "POC", "BD") #add MAOC and POC later

#Return the ones included in this project
proj_stock_inds <- stock_inds[stock_inds %in% proj.indicators]

#If SOC and BD are both present, return SOC, otherwise, SOC should not be included
if (all(c("SOC", "BD") %in% proj.indicators)) {
  proj_stock_inds <- setdiff(proj_stock_inds, "BD") # Keep SOC, remove BD
} else {
  proj_stock_inds <- setdiff(proj_stock_inds, c("SOC", "SIC", "BD")) # Remove both if not both are present
}

#Append "_stocks_summary" to each indicator to match the names of the objects made above

stocks_summaries <- paste0(proj_stock_inds, "_stocks_summary")


standardize_columns <- function(df) {
  df %>%
    mutate(
      indicator = as.character(indicator),
      mean = as.numeric(mean),
      se = as.numeric(se),
      plot = as.character(plot)
    )
}

tables_list<-mget(stocks_summaries)

for (i in seq_along(tables_list)) {
  tables_list[[i]] <- standardize_columns(tables_list[[i]])
}

# Retrieve the actual objects using mget and pass them to rbind
stocks_summary <- do.call(rbind, tables_list)

#add rows for all pools combined
summed_means <- stocks_summary %>% filter(indicator != "MAOC")%>%filter(indicator != "POC")%>%
  group_by(plot) %>%
  dplyr::summarize(mean = sum(mean, na.rm=TRUE), .groups = 'drop')

stocks_summary <- bind_rows(
  stocks_summary,
  summed_means %>%
    mutate(indicator = "All", se = NA, depth = NA)  # Assign placeholder values for other columns
)

#change stocks_summary format to match Soil.Means to bind and combine into one summary table
stocks_summary_fortable<-stocks_summary%>%
  rename(Indicator = indicator) %>%
  mutate(Units = "metric tons of carbon/acre")%>%
  select(-c(se, depth)) %>%
  pivot_wider(names_from = plot, values_from = mean) %>%
  filter(Indicator != "All")

Soil.Means<-rbind(Soil.Means, stocks_summary_fortable)
}

```
```{r}
#Create plot summary table
  if (length(unique(border$plot_type))==1) { # Use this table format if there's only a treatment site
    SummaryTable <- Soil.Means %>% 
      kbl(caption = "Soil Metrics", digits = 2, col.names = c("Indicator", "Unit", "Treatment"))
  } 
  if (length(unique(border$plot_type))==2) { # Use this table format if there's a treatment and control site
    SummaryTable <- Soil.Means %>% 
      kbl(caption = "Soil Metrics", digits = 2, col.names = c("Indicator", "Unit", "Control", "Treatment"))
  }


SummaryTable %>%
  kable_styling(position='center', full_width = F)

#Add standard error or deviation to this table? Is there a nice way to group this up into variability levels?
```

```{r Texture Explanation, results='asis', eval = "Tx" %in% proj.indicators}
asis_output("### Texture and organic carbon\\n") #CONDITIONAL HEADER
```
```{r results='asis'}
if ("Tx" %in% proj.indicators){cat("The graphic below represents where each soil sample falls in a texture triangle, indicating the percentage of clay-sized, silt-sized, and sand-sized particles. The corresponding USDA texture categories are named inside the triangle. In general, we expect clays to store more SOC than sands. To visualize and explore this effect, the size and color of each point represents the relative SOC % for that soil sample. Darker and larger points represent more SOC content, while smaller and lighter points represent less SOC content.")}

```
```{r Texture T and C, results='asis'}
if ("Tx" %in% proj.indicators & length(unique(border$plot_type))==2){cat("Since this project includes a treated and control site, it's also important to note how well the texture values between plots 'match' one another - this helps us interpret differences in carbon dynamics between the sites. Two texture triangles are shown, one for the treated site, and one for the control site.")}

```

```{r fig.height=6, fig.cap="Texture triangle(s) showing texture classifications for samples in the study area. The size and color of bubbles on the plot represent percent soil organic carbon content for each sample, where larger and darker bubbles correspond to higher percentages."}
if ("Tx" %in% proj.indicators){ #only do any of this if texture was included as an indicator (med and high ACTION roadmaps)

  if (length(unique(border$plot_type))==1){ #make one triangle for plots with only T site
    
  texture <- PointData.proj %>% 
    rename(SAND=Sand, SILT=Silt, CLAY=Clay) %>%
    filter(!is.na(CLAY)) %>%
    filter(!is.na(SAND)) %>%
    filter(!is.na(SILT))
library(soiltexture)
TT.plot(
  class.sys = "USDA.TT",
  tri.data = texture,
  z.name = "SOC",
  main = NA,
  grid.show = FALSE,
 class.lab.show="full",
 css.lab = c("Clay %", "Silt %", "Sand %"),
  arrows.show=TRUE,
 cex.axis = 0.8,
 cex.lab = 0.8,
 lwd.lab = 0.8,
 z.col.hue = 0.4,
 z.pch = 1,
 arrows.lty='blank',
 new.mar =c(5.1, 0.1, 0.02, 0.1) #bottom, left, top, right
) 
  }
  
  if (length(unique(border$plot_type))==2){ #make 2 triangles for plots with a T and a C site
  
    library(gridExtra)
    
    texture_T <- PointData.proj %>% 
    rename(SAND=Sand, SILT=Silt, CLAY=Clay) %>%
    filter(!is.na(CLAY)) %>%
    filter(!is.na(SAND)) %>%
    filter(!is.na(SILT)) %>%
    filter(plot_typee == "T")
    
    texture_C <- PointData.proj %>% 
    rename(SAND=Sand, SILT=Silt, CLAY=Clay) %>%
    filter(!is.na(CLAY)) %>%
    filter(!is.na(SAND)) %>%
    filter(!is.na(SILT)) %>%
    filter(plot_typee == "C")

#this parts funny; in order to get the two plots to show side by side, i have to save them as PNGs first; using a temp directory to keep the working directory clean
    
temp_dir<-tempdir()
TextureT_path <- file.path(temp_dir, "TextureT")
TextureC_path <- file.path(temp_dir, "TextureC")
         
png(TextureT_path)
TT.plot(
  class.sys = "USDA.TT",
  tri.data = texture_T,
  z.name = "SOC",
  main = "Treated Site",
  grid.show = FALSE,
 class.lab.show="full",
 css.lab = c("Clay %", "Silt %", "Sand %"),
 arrows.show=TRUE,
 cex.axis = 0.8,
 cex.lab = 0.8,
 lwd.lab = 0.8,
 z.col.hue = 0.4,
 z.pch = 1,
 arrows.lty='blank',
 new.mar = c(.2, 1, .2, 1) #bottom, left, top, right
) 
dev.off()

png(TextureC_path)
TT.plot(
  class.sys = "USDA.TT",
  tri.data = texture_C,
  z.name = "SOC",
  main = "Control Site",
  grid.show = FALSE,
 class.lab.show="full",
 css.lab = c("Clay %", "Silt %", "Sand %"),
  arrows.show=TRUE,
 cex.axis = 0.8,
 cex.lab = 0.8,
 lwd.lab = 0.8,
 z.col.hue = 0.4,
 z.pch = 1,
 arrows.lty='blank',
 new.mar = c(.2, 1, .2, 1) #bottom, left, top, right
) 
dev.off()

library(grid)
imgT <- rasterGrob(png::readPNG(TextureT_path), interpolate = TRUE)
imgC <- rasterGrob(png::readPNG(TextureC_path), interpolate = TRUE)

grid.arrange(imgT, imgC, ncol = 2)
  }
  
}


```
```{r results='asis', eval = "Tx" %in% proj.indicators}
asis_output("### Soil carbon stocks\\n") #CONDITIONAL HEADER
```

```{r Dynamic text carbon stocks, results='asis'}

if (ProjectTracker$Roadmap!="low"){cat("The following graph shows calculated carbon stocks values for the study area. Carbon stocks represent the amount of carbon stored in the study area to the specified sampling depth. These 'violin plots' also show the variability of carbon stocks across the site. The widest part of the plot represents the most common carbon level in the study area. The white dot represents the average value, and white lines show one standard deviation above and below the average.")}

```
```{r Rapid Carbon Asessment regional baselines}
#NOT USING IN BASIC VERSION
##Here, I will pull in data from USDAs rapid carbon assessment for the county the project is location in for comparison to our measured values
#library(soilDB)
#library(aqp)
#library(tigris)

#proj.county<-counties(cb = TRUE, filter_by=border)%>%st_transform(4326) #pull in the county that the proj border falls within
#county.bbox<- st_bbox(proj.county) #make a bbox for the county (RaCA fetch only wants a bbox)
#countybbox.RaCA<-fetchRaCA(bbox=county.bbox) #run the county bbox through raCA fetch to get carbon data
#countybbox.RaCA.sf<-st_as_sf(site(countybbox.RaCA$pedons), coords = c("x", "y"), crs = 4326) #turn RaCA spatial data into an SF object
#county.RaCA <- st_intersection(proj.county, countybbox.RaCA.sf) #trim RaCA points to the actual county boundary

###Visual Check Steps###
#plot(proj.county$geometry)
#plot.new()
#plot(countybbox.RaCA.sf$geometry)#, add=TRUE)
#plot(proj.county$geometry, add=TRUE)
#plot(county.RaCA, add=TRUE)
#mapview(countybbox.RaCA.sf)+mapview(proj.county)

#add carbon stocks data to the sf object based on the rcapid column
#county.RaCA<- county.RaCA%>%
#  select(rcapid, geometry) %>%
#  left_join(countybbox.RaCA$stock, by="rcapid")%>%
#  select(rcapid, geometry, value_30cm)

#some filtering and calculations are needed to wrangle the SOC data; this is only needed for low inference projects
#county.soc_perc_0.30<-countybbox.RaCA$sample%>% #get the sample dataframe
#  filter(sample_top<30&sample_bottom<30)%>% #filter so that only samples between 0 and 30 remain
#  group_by(rcapid)%>% #group by rcapid
#  dplyr::summarize(SOC_perc_0.30 = mean(soc, na.rm = TRUE)) #get an average soc concentration across all depths measured for that rcapid

#Put it all together
#county.RaCA<- county.RaCA %>%
#  left_join(county.soc_perc_0.30, by="rcapid") %>%
#  select(rcapid, geometry, value_30cm, SOC_perc_0.30)%>%
#  mutate(group=1)

#county.RaCA.stocks.mean<-mean(county.RaCA$value_30cm)
#county.RaCA.concentrations.mean<-mean(county.RaCA$SOC_perc_0.30)


```

```{r fig.cap="Carbon stocks comparing treated and control sites for each relevant indicator"}
if (ProjectTracker$Roadmap != "low"){

###Preparing variables and aesthetics###
if (all(c("POC", "MAOC") %in% stocks_summary$indicator)) {
  stocks_summary_facet<-stocks_summary%>%filter(indicator != c("POC", "MAOC"))
} else { stocks_summary_facet<-stocks_summary}

Var.Labels <- c('All pools combined', 'Soil Organic Carbon', 'Soil Inorganic Carbon')
names(Var.Labels) <- c('All', 'SOC_stocks_tons.acre', 'SIC_stocks_tons.acre')
cbbPalette <- c("#384F8D80","#384F8Dff") 

#define layout for facets depending on the number of indicators included
if(length(unique(stocks_summary_facet$indicator))==4){design <- matrix(c(1, 1, 2, 3, 4, 4), 2, 3)}
if(length(unique(stocks_summary_facet$indicator))==6){design <- matrix(c(1,1,2,3,4,5,6,6), 2, 4)}
if(length(unique(stocks_summary_facet$indicator))==3){
  design <- matrix(c(1, 2, 3), 1, 3)}

if (ProjectTracker$Roadmap != "low"){ #this will throw an error if you try to run a project with no stocks through it
df_long <- PointData.proj %>%
  pivot_longer(
    cols = contains("stocks_tons"), # Select columns to pivot
    names_to = "Stocks_Indicator",          # Name for the new column with column names
    values_to = "Tons.Acre"              # Name for the new column with values
  )
}

facet_order <- c("SOC_stocks_tons.acre", "SIC_stocks_tons.acre", "POC_stocks_tons.acre", "MAOC_stocks_tons.acre")

df_long$Stocks_Indicator <- factor(df_long$Stocks_Indicator, levels = facet_order)

ggplot(df_long, aes(x = plot_typee, y = Tons.Acre, fill=plot_typee)) +
#geom_hline(yintercept = county.RaCA.stocks.mean, linetype = "dashed", color = "red") +  # Horizontal line #NOT USING IN BASIC VERSION
  geom_violin(trim=TRUE,  color = "black") + #, show.legend=ifelse(length(unique(df_long$plot_typee))>1, TRUE, FALSE))
  facet_wrap(~ Stocks_Indicator) +  # Facet by Indicator column
  theme_minimal() +
  geom_point(aes(color = "Sampling point values"), alpha = .5, size = 3, position = position_jitterdodge(jitter.width = 0.1, jitter.height = 0.1))+
  scale_color_manual(values = c("Sampling point values" = "black"), name = "")+
  stat_summary(
    fun.data = function(x) {
      mean_x <- mean(x, na.rm = TRUE)
      se_x <- sd(x, na.rm = TRUE) / sqrt(length(x[!is.na(x)]))  # Standard error
      data.frame(
        y = mean_x,
        ymin = mean_x - se_x,
        ymax = mean_x + se_x
      )
    },
    geom = "pointrange",
    color = "white"
  ) +
  theme(axis.title.x=element_blank(),
        plot.caption = element_text(hjust = 0),
        plot.title = element_text(hjust = 0.5), 
        axis.text.x=element_blank(), 
        #legend.position='bottom',
        axis.ticks.x=element_blank()) +
  scale_fill_manual(values=cbbPalette,
                    name = str_wrap('Plot average +/- 1 standard deviation', width = 15),
                    breaks = c('C', 'T'),
                    labels = c('control', "treatment"))+
  labs(x = '', y = 'Carbon Stored (tons/acre)')+
  facet_manual(~Stocks_Indicator, 
               design = design, 
               #scales = "free_y", 
               labeller = as_labeller(Var.Labels, 
                                      default=label_wrap_gen(20)))+
  expand_limits(y=0.1)#+ #limits the lowest value for the y axis so graphs with 0 values dont show 
}

```

```{r fig.cap=""}



```


### Dynamic map: all measured values

Use the map below to explore all measured values for each sampling location. Select a layer to visually explore values for a given indicator. Click a point to see all measured values at that point. 

```{r Dynamic map}

if (ProjectTracker$Roadmap != "low"){
stockscolumns<-paste0(proj_stock_inds, "_stocks_tons.acre") #use the project stock indicators previously created to replicate the names of the stocks columns
}

proj.indicators.nonbiomass<-proj.indicators.SSC[!proj.indicators.SSC %in% c("AHB", "HRB", "AWB", "WRB")] #get the rest of the project indicators that can be reported not as stocks...this is irrelevant for ACTION but will leave anyways

if (ProjectTracker$Roadmap != "low") { #combine into one vector 
  dynamicmap.inds <- c(stockscolumns, proj.indicators.nonbiomass)
} else {
  dynamicmap.inds <- proj.indicators.nonbiomass
}

dynamicmap.inds <- c("SOC", dynamicmap.inds[dynamicmap.inds != "SOC"]) #ensure SOC% always comes first; important for map rendering

PointData.projDYNAMIC<-PointData.proj%>%
  select(Sample.ID, plot_typee, all_of(dynamicmap.inds))


points<-points%>%
  rename(Sample.ID=name)%>%
  select(Sample.ID, geometry)
DataMap.proj<-left_join(points, PointData.projDYNAMIC, by="Sample.ID")

base_colors <- rainbow(length(dynamicmap.inds)) #create a rainbow palette from which to create color ramps

legends_names <- c(
  "SOC_stocks_tons.acre" = "SOC stocks (tons/acre)",
  "SIC_stocks_tons.acre" = "SIC stocks (tons/acre)",
  "MAOC_stocks_tons.acre" = "MAOC stocks (tons/acre)",
  "POC_stocks_tons.acre" = "POC stocks (tons/acre)",
  "SOC" = "SOC %",
  "SIC" = "SIC %",
  "MAOC" = "MAOC %",
  "POC" = "POC %",
  "BD" = "BD (g/cm3)",
  "Sand" = "Sand %",
  "Silt" = "Silt %",
  "Clay" = "Clay %",
  "pH" = "pH"
)

#these bits are needed so that the popup table comes in correctly 
rename_map <- c(
  SOC_stocks_tons.acre = "SOC stocks (tons/acre)",
  SIC_stocks_tons.acre = "SIC stocks (tons/acre)",
  MAOC_stocks_tons.acre = "MAOC stocks (tons/acre)",
  POC_stocks_tons.acre = "POC stocks (tons/acre)",
  SOC = "SOC %",
  SIC = "SIC %",
  MAOC = "MAOC %",
  POC = "POC %",
  BD = "BD (g/cm3)",
  Sand = "Sand %",
  Silt = "Silt %",
  Clay = "Clay %",
  pH = "pH"
)
df_forpopup <- DataMap.proj %>%
    mutate(across(any_of(dynamicmap.inds), ~round(.x,2)))%>%
  rename_with(~ rename_map[.x], .cols = any_of(names(rename_map)))
popupcols<-setdiff(names(df_forpopup), c("geometry", "plot_typee", "plot_type"))


    pal <- colorFactor(c("white","black"), c("T", "C"))
  
    DynamicMap<-leaflet()%>% #establishing the basemap first
      addProviderTiles(providers$Esri.WorldImagery) %>%
      addPolygons(data = st_zm(border),
              fillOpacity = 0,
              color = ~ pal(plot_type),
              opacity=1)%>%
      addLegend(
      pal = pal, 
      values = border$plot_type,
      title = "Plot Type",
      position = "bottomleft",
      labFormat = function(type, cuts, p) { 
      c("Treatment", "Control")[match(cuts, c("T", "C"))]
    })
  
    overlay_groups <- c()

  
  for (i in seq_along(dynamicmap.inds)) {
    legend_name <- ifelse(dynamicmap.inds[i] %in% names(legends_names), 
                          legends_names[dynamicmap.inds[i]], 
                          dynamicmap.inds[i])
    
    #this prevents errors from being thrown when there are NAs 
    if (all(is.na(DataMap.proj[[dynamicmap.inds[i]]]))){domainz=c(0,1)
    }else{domainz=DataMap.proj[[dynamicmap.inds[i]]]}

    pal<- colorNumeric(palette = colorRampPalette(c("white", base_colors[i]))(100), domain =domainz)

   DynamicMap<-  DynamicMap %>%
          addProviderTiles(providers$Esri.WorldImagery) %>%  # Add satellite imagery as the basemap
          addCircleMarkers(
            data = DataMap.proj,
            color = ~pal(get(dynamicmap.inds[i])),   # Apply the color scale to the SOC field
            opacity = 1,
            radius = 3,
            group = legend_name,
            label = DataMap.proj$Sample.ID,
            popup=popupTable(df_forpopup, zcol=popupcols, row.numbers = FALSE, feature.id = FALSE)
              )%>%
       addLegend(
            pal = pal, 
            values = DataMap.proj[[dynamicmap.inds[i]]],
            title = legend_name,
            group = legend_name
          )
   
   overlay_groups <- c(overlay_groups, legend_name)
  }
    
 DynamicMap <- DynamicMap %>%
  addLayersControl(
    overlayGroups = overlay_groups, # Groups to toggle
    options = layersControlOptions(collapsed = TRUE)
  )%>%hideGroup(setdiff(overlay_groups, "SOC %"))
   
    
DynamicMap

```

## Frequently Asked Questions

#### Why is monitoring soil organic carbon important?
Soil organic carbon makes up the majority of soil organic matter which provides a variety of services in agro-ecosystems. Soil organic carbon benefits soil organisms by creating a structured, porous environment. In turn, these soil organisms then increase fertility by cycling nutrients from waste materials, leading to higher productivity. Soils with higher levels of organic carbon have higher water holding capacity contributing to overall landscape resilience. Understanding how soil organic carbon changes in response to management practices across a variety of soils and climates, will help us prioritize lands for maximum conservation planting impact.

#### How can I interpret 1 ton of carbon per acre?
One ton of carbon per acre is equal to 3.67 metric tons of CO2 removed from the atmosphere, equivalent to 1 year of passenger car emissions. It is important to note that 1 ton of carbon per acre in our soil data is only to a 12 inch depth; much more carbon can be stored below that depth.  

#### As a land steward, how do I use all of this information?
The information in this report provides a baseline to measure the impact of future management changes. As time series data is not currently available, comparing across different areas of your own farm or ranch is most informative. Explore the dynamic map to gauge how different sites across the study area differ in key metrics. Additionally, our team is working towards a reporting structure that will allow landowners to compare their Ag-C data to other sites within the network, especially to other enrolled farms and ranches in their region. As our database grows, network-wide and regional comparisons will provide an increasingly detailed understanding of differing practice impacts across spatial scales. An online user dashboard allowing Ag-C land stewards to view and compare their results is planned for launch in Fall of 2025.

#### To measure the impact of conservation practices, I need to monitor change over time. How do I sample a second time?
The ACTION project is designed to set land stewards up with quality baseline data before a new conservation practice is implemented. Under the Ag-C framework, each conservation practice has its own recommended resampling interval that ranges from 1 year to 10 years, based on the expected impact of the practice over time^[Consult the [`r proj.protocol` Handbook](`r ifelse(proj.protocol=='Range-C', 'https://www.pointblue.org/?sdm_process_download=1&download_id=19991', 'https://www.pointblue.org/?sdm_process_download=1&download_id=20943')`) for more information about resampling intervals by conservation practice.]. Our team is working to identify opportunities for continued monitoring at sites baselined through the ACTION project. Contact our team if you're interested in pursuing support for future resampling events or if you have existing support for future monitoring and would like to continue participating in the Ag-C Monitoring Program.


## Conclusion
Thank you again for your participation in the Ag-C Monitoring Program funded by the USDA ACTION for Climate-Smart Agriculture project. For more information about project design, further interpretation of results, or to access the raw data from your study site, please reach out to [RangeC\@pointblue.org](mailto:RangeC@pointblue.org) or [CropC\@pointblue.org](mailto:CropC@pointblue.org). Our team is happy to engage with additional questions or feedback. Your participation with the Ag-C Monitoring Program and sharing data will launch new scientific understanding of conservation management and support improved incentive structures across the nation.