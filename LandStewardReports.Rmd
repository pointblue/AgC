---
title: |
  <img src="ReportRef/Images/PBLogo.png" style="width: 300px;">  
  <img src="ReportRef/Images/AgCLogo.png" style="width: 500px;">  
  Land Steward Report
author: "Avalon Cook"
date: "`r format(Sys.Date(), '%B %d %Y')`"
output:
  bookdown::html_document2:
    number_sections: FALSE
    toc: true
    toc_float: true
    toc_depth: 3  # Include up to level 2 headers
    self_contained: true
dev: png
params:
  project_name: JPNV
---
```{r Setup, echo=FALSE, message=FALSE, warning=FALSE, error=FALSE, results='hide'}

#Created by: Avalon Cook
#Created: 20231214
#Updated: 20241126 (by AC)

knitr::opts_chunk$set(
	echo = FALSE,
	message = FALSE,
	warning = FALSE, 
	error=FALSE)

setwd("Z:/Soils Team/AgC")
data_path<-("Z:/Soils Team/AgC Data/Master Datasheets")

#renv::restore() #CHECK add renv to this rproj?

library(knitr)
library(sf)
library(leaflet)
library(googlesheets4)
library(dplyr)
library(kableExtra)
library(tidyr)
library(ggplot2)
library(ggh4x)
library(stringr)
library(soiltexture)
library(leafpop)
library(gridExtra)
library(grid)

gs4_auth_configure(api_key = 'AIzaSyBEULjhG3_r_ZX6F7ZKDEUQ5yOgUbKVh6o') #this auth key is linked to Avalon's account and should prevent from the user needing to manually authorize each time, like in the line below

format_list <- function(x) { #oxford comma text list formatter (GPT)
  n <- length(x)
  if (n == 0) {
    ""
  } else if (n == 1) {
    x
  } else if (n == 2) {
    paste(x, collapse = " and ")
  } else {
    paste0(
      paste(x[-n], collapse = ", "),
      ", and ",
      x[n]
    )
  }
}

#gs4_auth() #this line will initiate a prompt in your console and take you to your browser to approve access to your Google Drive
```
```{r, project.summary}
######################NEW#######################
#pulling in spatial data
spatial_path <- "Z:/Soils Team/AgC Data/Raw Data/Spatial Data/ZippedShapefiles" #define the location of ACTION GIS data

border_pattern <- paste0(params$project_name, "_border.zip") #specify the pattern of the border file
borderzip_file <- list.files(
  path = spatial_path,
  pattern = border_pattern,
  recursive = TRUE,
  full.names = TRUE) # Search for the matching file, recursively
temp_folder1 <- tempfile() #create a temp directory where the shapefile can be unzipped
unzip(borderzip_file, exdir = temp_folder1)
border_file<-list.files(temp_folder1, pattern = "\\_border.shp$", full.names = TRUE)
border<- read_sf(border_file) #read in project polygon

#repeat for sampling points
points_pattern <- paste0(params$project_name, "_pointsfinal.zip") 
pointszip_file <- list.files(
  path = spatial_path,
  pattern = points_pattern,
  recursive = TRUE,
  full.names = TRUE) 
temp_folder2 <- tempfile() 
unzip(pointszip_file, exdir = temp_folder2)
points_file<-list.files(temp_folder2, pattern = "\\_pointsfinal.shp$", full.names = TRUE)
points<- read_sf(points_file) 
######################NEW#######################


###################NEW reading in master datasheets###################
#Reading in master datasheets and filtering by project of interest
list_dfs_field<-list.files(file.path(data_path, "FieldLevel", ""), pattern = "\\.csv$", full.names = TRUE)
FieldLevel<-list_dfs_field[which.max(as.Date(gsub("\\D","", list_dfs_field), format = "%Y%m%d"))]%>%
  read.csv()%>%
  filter(project_name == params$project_name)

list_dfs_point<-list.files(file.path(data_path, "PointLevel", ""), pattern = "\\.csv$", full.names = TRUE)
PointLevel<-list_dfs_point[which.max(as.Date(gsub("\\D","", list_dfs_point), format = "%Y%m%d"))]%>%
  read.csv()%>%
  filter(project_id == params$project_name)

list_dfs_design<-list.files(file.path(data_path, "ProjectDesign", ""), pattern = "\\.csv$", full.names = TRUE)
ProjectDesign<-list_dfs_design[which.max(as.Date(gsub("\\D","", list_dfs_design), format = "%Y%m%d"))]%>%
  read.csv()%>%
  filter(project_id == params$project_name)

#add project design datasheet, then assign all the variables created above

#Establishing variables for report structure
proj.protocol <- FieldLevel$rangec_cropc[1]
proj.inscore <- ProjectDesign$inference_score[1]
proj.propertyname <- ProjectDesign$ranch_name[1]
proj.implementationyear <- if(is.na(ProjectDesign$proj_practice_year[1])){""}
pract_codes<-read.csv('practice_abbreviations.csv')
practs_vec<-strsplit(ProjectDesign$conservation_practice[1], ",\\s*")[[1]]
practs_full<-pract_codes$Practice[match(practs_vec, pract_codes$Abbreviation)]
proj.practicetype <- format_list(practs_full)
proj.title <- paste0(proj.propertyname, ": ", proj.implementationyear, proj.practicetype)
############################################################################

```

# `r proj.title` {.unlisted .unnumbered}

## Background
Thank you for participating in the Agricultural Carbon Monitoring Program. Ag-C was developed to help practitioners conduct transparent, fit-for-purpose monitoring of aboveground and belowground carbon in response to common conservation practices. At the same time that it supports management efforts at the farm scale, Ag-C is designed to evaluate management effects on carbon at regional scales when data is aggregated network-wide in the secure Point Blue Science Cloud. The collected information, from management history to field measurements, will support greater understanding of commonly incentivized practice impact on ecosystem carbon. 

The Agricultural Carbon ("Ag-C") Monitoring Program was developed by the Soils Team at Point Blue Conservation Science to help practitioners conduct transparent, fit-for-purpose monitoring of carbon dynamics in response to rangeland and cropland management. This report reviews the initial measurement for the baseline carbon indicators measured at your agricultural site. Continued use of the Ag-C protocols over time can assess the impact of your conservation effort. 

This report reviews monitoring efforts to date for the carbon indicators measured at your agricultural site. Continued use of the Ag-C protocols over time can assess the long-term impact of your conservation effort. Find additional information and funding updates for continued use of the Ag-C Monitoring Program on [our landing page](https://www.pointblue.org/ag-c/). 

## Project Design
The Ag-C program offers a flexible approach to designing a monitoring program. This includes the option to select carbon indicators of interest, tailor methods to your goals and resources, and match project design elements to your context. Ag-C is made of two major components: Range-C to accommodate monitoring in rangeland systems and Crop-C to accommodate monitoring in cropland systems. At your site, `r proj.protocol` was used as the guiding framework for developing a monitoring plan.^[To learn more about designing a monitoring program with `r proj.protocol`, consult the [`r proj.protocol` Handbook](`r ifelse(proj.protocol=='Range-C', 'https://www.pointblue.org/?sdm_process_download=1&download_id=19991', 'https://www.pointblue.org/?sdm_process_download=1&download_id=20943')`)]

To support interpretability and comparability, `r proj.protocol` assigns each monitoring project an “inference score” which reflects how decisions made in the project design process impact the overall rigor and reliability of the resulting data. Inference scores range from 40 to 100, where a higher score generally reflects greater confidence in the project's findings or a more holistic characterization of carbon dynamics in the study site. Nonetheless, all `r proj.protocol` projects represent a minimum standard of rigor and reliability. 

The monitoring plan developed for the `r paste0(proj.implementationyear, " ", proj.practicetype)` practice at `r proj.propertyname ` results in a `r proj.protocol` inference score of `r proj.inscore`.
```{r, echo=FALSE, fig.height=3, fig.align='center', fig.cap="A visual representation of how different project design decisions impact the final inference score"}
#CHECK new graphic necessary?
#not including this for now because we need to make an updated version for crop-c; the one i currently have is range-c specific
#Refer to the graphic below for a visual representation of how different project design decisions contribute to the inference score. 
#knitr::include_graphics("InferenceScore.png") # CHANGE THIS TO ACCOMODATE BOTH PROTOCOLS
```

### Carbon indicators
The following table includes carbon indicators that were included in this monitoring project and their corresponding acronyms that will be used in the following tables, graphs, and maps. A description of each indicator and reported units are provided. 

```{r, , results='asis'}
if ("Extra" %in% proj.indicator.table$Status){
cat(paste0("Note that your project included indicators that aren’t directly related to carbon dynamics. These indicators provide additional information about site dynamics but aren’t covered in the ", proj.protocol,  " handbook."))}
```

```{r, updated}
proj.indicator.db<-read.csv("ReportRef/indicator_descriptions.csv", check.names=FALSE)#read in the indicator descriptions reference sheet

proj.indicators<-proj.indicator.db$Acronym

proj.indicator.table<-proj.indicator.db%>% 
  rowwise() %>%
  filter(!all(is.na(PointLevel[[CheckCol]])))%>%
  filter(!Acronym %in% c("Sand", "Silt", "Clay"))


ind.table.kbl<-proj.indicator.table%>%select(Indicator, Acronym, Description, `Final units`)

Table1<-kbl(ind.table.kbl,
      caption= "Description of carbon indicators",
      col.names = gsub("[.]", " ", x=names(ind.table.kbl)), 
      row.names = FALSE,
      vline = "|",
      linesep = "\\addlinespace",
      align= c('llll'))

Table1 %>% 
  kable_styling(position='center', full_width = T) %>%
  column_spec(1, width="1.25in")%>%
  column_spec(2, width="0.5in")%>%
  column_spec(3, width="2.5in")%>%
  column_spec(4, width="1.75in")%>%
  row_spec(0, bold=TRUE)%>%
  collapse_rows(columns = c(1, 3, 4), valign = "middle") #merges adjacent cells with identical values
```

### Spatial design
The interactive map below shows the boundaries of the study area for monitoring and how sampling points are distributed. 
```{r}
#spatial data was pulled in above. Use this chunk to render your map.

border <- st_transform(border, crs = 4326)
points <- st_transform(points, crs = 4326)
points$labels <- substr(points$name, nchar(points$name) - 1, nchar(points$name))

pal <- colorFactor(c("white","black"), c("T", "C"))

leaflet() %>%
  addProviderTiles(providers$Esri.WorldImagery) %>%
  addPolygons(data = st_zm(border),
              fillOpacity = 0,
              color = ~ pal(plot_type),
              opacity=1)%>%
     addLegend(
      pal = pal, 
      values = border$plot_type,
      title = "Plot Type",
      position = "bottomleft",
      labFormat = function(type, cuts, p) { 
      c("Treatment", "Control")[match(cuts, c("T", "C"))]
    })%>%
  addLabelOnlyMarkers(data=points,
                      label = points$labels, 
                      labelOptions = labelOptions(
                        noHide = TRUE, 
                        direction = "center",
                       offset = c(0, 0),
                      style = list(
                              "font-weight" = "bold", 
                              "padding" = "1px", 
                              "border-radius" = "4px"
                                                  )))


```
```{r Dynamic text generation 1, results='asis'}
#this section states which, if any, indicators were measured at every sampling point and removes them from the following legend table

allpoints.list <- proj.indicator.table$CheckCol[
  proj.indicator.table$CheckCol %in% names(PointLevel) &    # must exist
    sapply(proj.indicator.table$CheckCol, function(col) all(!is.na(PointLevel[[col]])))
]

allpoints.table <- proj.indicator.table %>%
  filter(CheckCol %in% allpoints.list)

if (length(allpoints.list)>0){
cat("The following indicators were measured at every sampling point:", paste(allpoints.table$Indicator, collapse = ", "), "<br><br>")}
```
```{r Dynamic text generation 2, indicator.legend, results='asis'}

if (identical(allpoints.list, proj.indicator.table)==FALSE){ #only proceed if some indicators were not measured at every point
  
  #identifying indicators that were measured at a subset of points
  subset.inds <- proj.indicator.table$CheckCol[ 
  proj.indicator.table$CheckCol %in% names(PointLevel) &    # must exist
    sapply(proj.indicator.table$CheckCol, function(col) any(is.na(PointLevel[[col]])))] 
  
  #checking if all those subset indicators were done at the same points -- if so we'll just list them instead of making a table
  if (all(apply(!is.na(PointLevel[subset.inds]), 1, function(x) all(x) | all(!x)))){ #returns TRUE if all subset indicators were measured at the same sampling points
    subset_points <- PointLevel$sample_id[complete.cases(PointLevel[subset.inds])]
    subset.inds.name<-proj.indicator.table$Indicator[proj.indicator.table$CheckCol %in% subset.inds]
    cat(paste0("The following indicators were measured at ", format_list(subset_points), ": ", format_list(subset.inds.name),"<br><br>"))
  }
  
  #CHECK Here is where we go back to generating the table for when not all subset inds were measured at the same point. Not relevant for current report deadline. Model based on pilot reports code when ready
  if (all(apply(!is.na(PointLevel[subset.inds]), 1, function(x) all(x) | all(!x)))==FALSE){ 
    cat("Indicators that were only measured at some sampling points are listed in the table below.")
    
    #might have to generate the table in a different chunk, don't remember
  }
  
}

```
```{r, other spatial design elements, results='asis'}
if (ProjectDesign$composite==TRUE){
  cat("Each soil sample was composed of smaller composited samples to capture small-scale variability at each sampling point. ")
}

if (ProjectDesign$point_generation_method=="GIS"){
  cat("Sampling points were randomly selected within the monitoring boundary using mapping software and located in the field by GPS.")
}else{cat("Sampling points were randomly selected using the Range-C Point Selector tool and paced out in the field.")}

#CHECK add statement for stratification? Not worried about it right now but may come back after deadline
```


### Other design elements
The Ag-C framework flexibly accommodates different project design approaches. For example, the most rigorous project would include baseline monitoring before the conservation practice is implemented, as well as parallel monitoring at an untreated control site into the future. Although not logistically possible for every project, these elements together provide highly interpretable results. 

```{r Dynamic text Baseline and Control, results='asis'}

if (ProjectDesign$control_baseline=="TRUE" & length(unique(border$plot_type))==2){cat(paste0("This ", proj.protocol, " project includes baseline monitoring before the conservation practice was implemented as well as parallel monitoring at an untreated control site.", "<br><br>"))}

if (ProjectDesign$control_baseline=="TRUE" & length(unique(border$plot_type))==1){cat(paste0("This ", proj.protocol, " project includes baseline monitoring before the conservation practice was implemented, but did not include parallel monitoring at an untreated control site.", "<br><br>"))}

if (ProjectDesign$control_baseline=="FALSE" & length(unique(border$plot_type))==2){cat(paste0("This ", proj.protocol, " project includes parallel monitoring at an untreated control site, but did not capture baseline conditions before practice implementation.", "<br><br>"))}
  
if (ProjectDesign$control_baseline=="FALSE" & length(unique(border$plot_type))==1){cat(paste0("This ", proj.protocol, " project did not capture baseline conditions before practice implementation and was not able to compare current conditions to an untreated control site. While we are still able to characterize current conditions now and into the future, the results will have limited interpretability for understanding the full scope of practice impact.", "<br><br>"))}

#Do some conversions for a statement about max depth and depth increments
depth.increments.no <- ProjectDesign$depth_increments
convert_depths <- function(x) {
  sapply(strsplit(x, "_"), function(parts) {
    nums <- as.numeric(parts)
    nums <- round(nums * 0.393701)
    paste(nums, collapse = "-")
  })
}
depths.inches<-unique(PointLevel$target_depth)%>%convert_depths
max.depth.inches <- max(as.numeric(sub(".*-", "", depths.inches)))

cat(paste0("Soil samples were taken to a target maximum depth of ", max.depth.inches, " inches. " ))

if (depth.increments.no>1){
  cat("Depth increments from ", depths.string[1], " inches and ", depths.string[2], " inches were analyzed separately. ")
  
  depth_sentence <- function(depths.string) {
  paste0(
    "Depth increments from ",
    paste(depths.string, collapse = ", "),
    " inches were analyzed separately."
  ) |>
    sub(", ([^,]*)$", " and \\1", x = _)
  }
  depth_sentence(depths.inches)
  
}

```

## Results

### All soil properties
The following table summarizes average values across the study area for all soil metric(s) included in your project. 
```{r Summarize non-stocks soil means} 

#creating a vector of value names that match the names in PointLevel
if ("Tx" %in% proj.indicators==TRUE) {
  proj.indicators.SSC<-c(proj.indicator.table$CheckCol, "sand", "silt")
} else {proj.indicators.SSC <- proj.indicator.table$CheckCol}

PointLevel<-PointLevel%>% 
  mutate(plot_type = "T")#substr(sample_id, 6, 6)) #CHECK! should be temporary (will get built into PointLevel)

Project.Means <- PointLevel %>%
                    dplyr::group_by(plot_type) %>%
                    dplyr::summarise(across(all_of(proj.indicators.SSC), \(x) mean(x, na.rm = TRUE))) #find the mean for each indicator grouped by plot

Means.Pivot1<- Project.Means %>% pivot_longer(cols=all_of(proj.indicators.SSC), names_to ='Indicator') %>%
          pivot_wider(names_from = c("plot_type"), values_from = value)%>%#pivot so that indicators are row names and plot type and depth increment combinations are column names
           left_join( #add the units column (CHECK,)
    proj.indicator.table %>% select(CheckCol, UnitsTable),
    by = c("Indicator" = "CheckCol")
  ) %>%
  mutate(
    Units = case_when(
      Indicator %in% c("sand", "silt", "clay") ~ "%",           # special values
      str_ends(Indicator, "_stocks") ~ "tons/acre",             # ends with _stocks
      TRUE ~ UnitsTable                                          # default mapping
    )
  ) %>%
  select(-UnitsTable)%>% #clunky way of fixing units...not worth chasing down rn
  mutate(
    # remove _stocks for matching if present
    Indicator_base = str_remove(Indicator, "_stocks$")
  ) %>%
  left_join(
    proj.indicator.table %>% select(Acronym, CheckCol),
    by = c("Indicator_base" = "CheckCol")
  ) %>%
  mutate(
    Acronym = case_when(
      Indicator_base == "sand" ~ "Sand",
      Indicator_base == "silt" ~ "Silt",
      Indicator_base == "clay" ~ "Clay",
      TRUE ~ Acronym                                # default mapping
    )
  ) 

Means.Pivot<-Means.Pivot1%>%
  select(-Indicator_base, -Indicator)
          
my_order <- c("SOC", "MAOC", "POC", "BD", "pH", "Sand", "Silt", "Clay")

Soil.Means <- Means.Pivot %>% select(Acronym, Units, everything())%>% #reorder columns
              mutate( #all the rest allows me to specify an order for the first few Ag-C metrics, and leave the rest alone
                  order_helper = match(Acronym, my_order),
                  original_order = row_number()
                ) %>%
                arrange(is.na(order_helper), order_helper, original_order) %>%
                select(-order_helper, -original_order)
```
```{r Calculating carbon stocks, eval=FALSE} 
###CHECK! OLD! don't run this, I'm skipping it##
##This should only happen if SOC and BD are present

#if (ProjectTracker$Roadmap != "low"){

##Calculating SOC stocks
#if ("BD" %in% proj.indicators == TRUE){
#PointData.proj$SOC_stocks_g.cm2<-PointData.proj$BD * (PointData.proj$SOC*0.01) * (30) #get soc stocks in g/cm2 to specified depth
#PointData.proj$SOC_stocks_tons.acre <- PointData.proj$SOC_stocks_g.cm2 *40470000/1000000 #convert to tons/acre to specified depth

#SOC_stocks_summary<-PointData.proj %>%
#  group_by(plot_type) %>%
#  summarise(
#    indicator = "SOC",
#    mean = mean(SOC_stocks_tons.acre, na.rm = TRUE),
#    se = sd(SOC_stocks_tons.acre, na.rm = TRUE) / sqrt(n()),) %>%
#  rename(plot=plot_type)%>%
#  select(indicator, mean, se, plot)


#PointData.proj$SIC_stocks_g.cm2<-PointData.proj$BD * (PointData.proj$SIC*0.01) * (30) #get soc stocks in g/cm2 to specified depth
#PointData.proj$SIC_stocks_tons.acre <- PointData.proj$SIC_stocks_g.cm2 *40470000/1000000 #convert to tons/acre to specified depth

#SIC_stocks_summary<-PointData.proj %>%
#  group_by(plot_type) %>%
#  summarise(
#    indicator = "SIC",
#    mean = mean(SIC_stocks_tons.acre, na.rm = TRUE),
#    se = sd(SIC_stocks_tons.acre, na.rm = TRUE) / sqrt(n()),) %>%
#  rename(plot=plot_type)%>%
#  select(indicator, mean, se, plot)

  
#}

#if (all(c("BD", "MAOC") %in% proj.indicators)==TRUE) {
#  PointData.proj$MAOC_stocks_g.cm2<-PointData.proj$BD * (PointData.proj$MAOC*0.01) * (30) #get soc stocks in g/cm2 to specified depth
#PointData.proj$MAOC_stocks_tons.acre <- PointData.proj$MAOC_stocks_g.cm2*40470000/1000000 #convert to tons/acre to specified depth

#MAOC_stocks_summary<-PointData.proj %>%
#  group_by(plot_type) %>%
#  summarise(
#    indicator = "MAOC",
#    mean = mean(MAOC_stocks_tons.acre, na.rm = TRUE),
#    se = sd(MAOC_stocks_tons.acre, na.rm = TRUE) / sqrt(n()),) %>%
#  rename(plot=plot_type)%>%
#  select(indicator, mean, se, plot)
#}

#if (all(c("BD", "POC") %in% proj.indicators)==TRUE) {
#  PointData.proj$POC_stocks_g.cm2<-PointData.proj$BD * (PointData.proj$POC*0.01) * (30) #get soc stocks in g/cm2 to specified depth
#PointData.proj$POC_stocks_tons.acre <- PointData.proj$POC_stocks_g.cm2 *40470000/1000000 #convert to tons/acre to specified depth

#POC_stocks_summary<-PointData.proj %>%
#  group_by(plot_type) %>%
#  summarise(
#    indicator = "POC",
#    mean = mean(POC_stocks_tons.acre, na.rm = TRUE),
#    se = sd(POC_stocks_tons.acre, na.rm = TRUE) / sqrt(n()),) %>%
#  rename(plot=plot_type)%>%
#  select(indicator, mean, se, plot)
#}

####bind all the summaries together into one table

#list all the indicators that can be reported as stocks
#stock_inds <- c("SOC", "SIC", "MAOC", "POC", "BD") #add MAOC and POC later

#Return the ones included in this project
#proj_stock_inds <- stock_inds[stock_inds %in% proj.indicators]

#If SOC and BD are both present, return SOC, otherwise, SOC should not be included
#if (all(c("SOC", "BD") %in% proj.indicators)) {
#  proj_stock_inds <- setdiff(proj_stock_inds, "BD") # Keep SOC, remove BD
#} else {
#  proj_stock_inds <- setdiff(proj_stock_inds, c("SOC", "SIC", "BD")) # Remove both if not both are present
#}

#Append "_stocks_summary" to each indicator to match the names of the objects made above

#stocks_summaries <- paste0(proj_stock_inds, "_stocks_summary")


#standardize_columns <- function(df) {
#  df %>%
#    mutate(
#      indicator = as.character(indicator),
#      mean = as.numeric(mean),
#      se = as.numeric(se),
#      plot = as.character(plot)
#    )
#}

#tables_list<-mget(stocks_summaries)

#for (i in seq_along(tables_list)) {
#  tables_list[[i]] <- standardize_columns(tables_list[[i]])
#}

## Retrieve the actual objects using mget and pass them to rbind
#stocks_summary <- do.call(rbind, tables_list)

##add rows for all pools combined
#summed_means <- stocks_summary %>% filter(indicator != "MAOC")%>%filter(indicator != "POC")%>%
#  group_by(plot) %>%
#  dplyr::summarize(mean = sum(mean, na.rm=TRUE), .groups = 'drop')

#stocks_summary <- bind_rows(
#  stocks_summary,
#  summed_means %>%
#    mutate(indicator = "All", se = NA, depth = NA)  # Assign placeholder values for other columns
)

#change stocks_summary format to match Soil.Means to bind and combine into one summary table
#stocks_summary_fortable<-stocks_summary%>%
#  rename(Indicator = indicator) %>%
#  mutate(Units = "metric tons of carbon/acre")%>%
#  select(-c(se, depth)) %>%
#  pivot_wider(names_from = plot, values_from = mean) %>%
#  filter(Indicator != "All")

#Soil.Means<-rbind(Soil.Means, stocks_summary_fortable)
}

```
```{r}
#Create plot summary table
  if (length(unique(border$plot_type))==1) { # Use this table format if there's only a treatment site
    SummaryTable <- Soil.Means %>% 
      kbl(caption = "Soil Metrics", digits = 2, col.names = c("Indicator", "Unit", "Treatment"))
  } 
  if (length(unique(border$plot_type))==2) { # Use this table format if there's a treatment and control site
    SummaryTable <- Soil.Means %>% 
      kbl(caption = "Soil Metrics", digits = 2, col.names = c("Indicator", "Unit", "Control", "Treatment"))
  }


SummaryTable %>%
  kable_styling(position='center', full_width = F)%>%
  collapse_rows(columns = 2, valign = "middle") #merges adjacent cells with identical values

#Add standard error or deviation to this table? Is there a nice way to group this up into variability levels?
```

```{r Texture Explanation, results='asis', eval = "Tx" %in% proj.indicators}
asis_output("### Texture and organic carbon\\n") #CONDITIONAL HEADER
```
```{r results='asis'}
if ("Tx" %in% proj.indicators){cat("The graphic below represents where each soil sample falls in a texture triangle, indicating the percentage of clay-sized, silt-sized, and sand-sized particles. The corresponding USDA texture categories are named inside the triangle. In general, we expect clays to store more SOC than sands. To visualize and explore this effect, the size and color of each point represents the relative SOC % for that soil sample. Darker and larger points represent more SOC content, while smaller and lighter points represent less SOC content.")}

```
```{r Texture T and C, results='asis'}
if ("Tx" %in% proj.indicators & length(unique(border$plot_type))==2){cat("Since this project includes a treated and control site, it's also important to note how well the texture values between plots 'match' one another - this helps us interpret differences in carbon dynamics between the sites. Two texture triangles are shown, one for the treated site, and one for the control site.")}

```

```{r fig.height=6, fig.cap="Texture triangle(s) showing texture classifications for samples in the study area. The size and color of bubbles on the plot represent percent soil organic carbon content for each sample, where larger and darker bubbles correspond to higher percentages."}
if ("Tx" %in% proj.indicators){ #only do any of this if texture was included as an indicator (med and high ACTION roadmaps)

  if (length(unique(border$plot_type))==1){ #make one triangle for plots with only T site
    
  texture <- PointLevel %>% 
    rename(SAND=sand, SILT=silt, CLAY=clay) %>%
    filter(!is.na(CLAY)) %>%
    filter(!is.na(SAND)) %>%
    filter(!is.na(SILT))
TT.plot(
  class.sys = "USDA.TT",
  tri.data = texture,
  z.name = "org_c",
  main = NA,
  grid.show = FALSE,
 class.lab.show="full",
 css.lab = c("Clay %", "Silt %", "Sand %"),
  arrows.show=TRUE,
 cex.axis = 0.8,
 cex.lab = 0.8,
 lwd.lab = 0.8,
 z.col.hue = 0.4,
 z.pch = 1,
 arrows.lty='blank',
 new.mar =c(5.1, 0.1, 0.02, 0.1) #bottom, left, top, right
) 
  }
  
  if (length(unique(border$plot_type))==2){ #make 2 triangles for plots with a T and a C site
  

    texture_T <- PointLevel %>% 
    rename(SAND=sand, SILT=silt, CLAY=clay) %>%
    filter(!is.na(CLAY)) %>%
    filter(!is.na(SAND)) %>%
    filter(!is.na(SILT)) %>%
    filter(plot_type == "T") #CHECK! This won't work right now until lisa adds this column to PointLevel
    
    texture_C <- PointLevel %>% 
    rename(SAND=Sand, SILT=Silt, CLAY=Clay) %>%
    filter(!is.na(CLAY)) %>%
    filter(!is.na(SAND)) %>%
    filter(!is.na(SILT)) %>%
    filter(plot_type == "C") #CHECK! This won't work right now until lisa adds this column to PointLevel

#this parts funny; in order to get the two plots to show side by side, i have to save them as PNGs first; using a temp directory to keep the working directory clean
    
temp_dir<-tempdir()
TextureT_path <- file.path(temp_dir, "TextureT")
TextureC_path <- file.path(temp_dir, "TextureC")
         
png(TextureT_path)
TT.plot(
  class.sys = "USDA.TT",
  tri.data = texture_T,
  z.name = "org_c",
  main = "Treated Site",
  grid.show = FALSE,
 class.lab.show="full",
 css.lab = c("Clay %", "Silt %", "Sand %"),
 arrows.show=TRUE,
 cex.axis = 0.8,
 cex.lab = 0.8,
 lwd.lab = 0.8,
 z.col.hue = 0.4,
 z.pch = 1,
 arrows.lty='blank',
 new.mar = c(.2, 1, .2, 1) #bottom, left, top, right
) 
dev.off()

png(TextureC_path)
TT.plot(
  class.sys = "USDA.TT",
  tri.data = texture_C,
  z.name = "org_c",
  main = "Control Site",
  grid.show = FALSE,
 class.lab.show="full",
 css.lab = c("Clay %", "Silt %", "Sand %"),
  arrows.show=TRUE,
 cex.axis = 0.8,
 cex.lab = 0.8,
 lwd.lab = 0.8,
 z.col.hue = 0.4,
 z.pch = 1,
 arrows.lty='blank',
 new.mar = c(.2, 1, .2, 1) #bottom, left, top, right
) 
dev.off()

imgT <- rasterGrob(png::readPNG(TextureT_path), interpolate = TRUE)
imgC <- rasterGrob(png::readPNG(TextureC_path), interpolate = TRUE)

grid.arrange(imgT, imgC, ncol = 2)
  }
  
}


```
```{r results='asis', eval = "bulk_density" %in% proj.indicators.SSC}
asis_output("### Soil carbon stocks\\n") #CONDITIONAL HEADER

```
```{r, results='asis', eval = "bulk_density" %in% proj.indicators.SSC}
asis_output("The following graph shows calculated carbon stocks values for the study area. Carbon stocks represent the amount of carbon stored in the study area to the specified sampling depth. These 'violin plots' also show the variability of carbon stocks across the site. The widest part of the plot represents the most common carbon level in the study area. The white dot represents the average value, and white lines show one standard deviation above and below the average.")
```


```{r, Calculating stocks}
#Calculating stocks on qualifying soil metrics
if ("bulk_density" %in% proj.indicators.SSC){ #CHECK this condition needs to be different when we get plant projects cause someone could have SOC% only but also have measured plants
stocks.inds <- c("total_c", "total_n", "org_c", "inorg_c", "maoc", "poc", "pon") #these are the columns that can be turned into stocks (CHECK hard coding these in for now. Not sure if there's a better solution)
for(col in intersect(proj.indicators.SSC, stocks.inds)) {
  new_col <- paste0(col, "_stocks")  # new column name
  PointLevel[[new_col]] <- PointLevel[[col]]*PointLevel$bulk_density*PointLevel$e_depth*0.4461 #calculating stocks in US tons / acre (percent to decimal cancels out) 
}
proj.indicators.SSC.stocks<- c(proj.indicators.SSC, paste0(intersect(proj.indicators.SSC, stocks.inds), "_stocks")) #add those new column names to my list of indicator columns

if (length(setdiff(intersect(proj.indicators.SSC, stocks.inds), c('poc_stocks', 'maoc_stocks')))>1){ #if the number of stocks indicators (minus poc and maoc) are greater than one, create a summed all stocks column
  
  PointLevel <- PointLevel %>%
  mutate(
    all_stocks = rowSums(
      select(., ends_with("_stocks"), -maoc_stocks, -poc_stocks), #create a column for all pools combined, but make sure you're not double-counting poc and maoc, since org_c should cover that
      na.rm = TRUE
    )
  )
  proj.indicators.SSC<-c(proj.indicators.SSC, "all_stocks")
}

}
```



```{r fig.cap="Carbon stocks variability and average"}
if ("bulk_density" %in% proj.indicators.SSC.stocks){

###Preparing variables and aesthetics###
#if (all(c("poc", "maoc") %in% proj.indicators.SSC.stocks)) {
#  stocks_summary_facet<-stocks_summary%>%filter(indicator != c("poc", "maoc"))
#} else { stocks_summary_facet<-stocks_summary}

Var.Labels <- c('All pools combined', 'Soil Organic Carbon', 'Soil Inorganic Carbon')
names(Var.Labels) <- c('All', 'org_c_stocks', 'inorg_c_stocks')
cbbPalette <- c("#384F8D80","#384F8Dff") 
length(grep("_stocks$", proj.indicators.SSC, value = TRUE))
#define layout for facets depending on the number of indicators included
if(length(grep("_stocks$", proj.indicators.SSC, value = TRUE))==4){design <- matrix(c(1, 1, 2, 3, 4, 4), 2, 3)}
if(length(grep("_stocks$", proj.indicators.SSC, value = TRUE))==6){design <- matrix(c(1,1,2,3,4,5,6,6), 2, 4)}
if(length(grep("_stocks$", proj.indicators.SSC, value = TRUE))==3){design <- matrix(c(1, 2, 3), 1, 3)}
else{design <- matrix(c(1, 2, 3), 1, 3)} #CHECK

df_long <- PointLevel %>%
  pivot_longer(
    cols = contains("_stocks"), # Select columns to pivot
    names_to = "Stocks_Indicator",          # Name for the new column with column names
    values_to = "Tons.Acre"              # Name for the new column with values
  )

facet_order <- c("org_c_stocks", "inorg_c_stocks", "poc_stocks", "maoc_stocks")

df_long$Stocks_Indicator <- factor(df_long$Stocks_Indicator, levels = facet_order)

library(shadowtext)
ggplot(df_long, aes(x = plot_type, y = Tons.Acre, fill=plot_type)) +
  geom_violin(trim=TRUE,  color = "black") + #, show.legend=ifelse(length(unique(df_long$plot_type))>1, TRUE, FALSE))
  facet_wrap(~ Stocks_Indicator) +  # Facet by Indicator column
  theme_minimal() +
  geom_point(aes(color = "Sampling point values"), alpha = .5, size = 3, position = position_jitterdodge(jitter.width = 0.1, jitter.height = 0.1))+
  scale_color_manual(values = c("Sampling point values" = "black"), name = "")+
  stat_summary(
    fun.data = function(x) {
      mean_x <- mean(x, na.rm = TRUE)
      se_x <- sd(x, na.rm = TRUE) / sqrt(length(x[!is.na(x)]))  # Standard error
      data.frame(
        y = mean_x,
        ymin = mean_x - se_x,
        ymax = mean_x + se_x
      )
    },
    geom = "pointrange",
    color = "white"
  ) +
  stat_summary(
    fun = mean,
    geom = "shadowtext", #requires package shadowtext
    bg.color = "black", #text outline color
    bg.r = 0.15,  #thickness of outline
    aes(label = sprintf("%.1f", ..y..)), #change decimal places printed by altering the digit
    color = "#FFD700", #text color
    hjust = -0.5,
    vjust = 0.2,
    fontface = "bold",
    size = 4
  )+
  theme(axis.title.x=element_blank(),
        plot.caption = element_text(hjust = 0),
        plot.title = element_text(hjust = 0.5), 
        axis.text.x=element_blank(), 
        axis.ticks.x=element_blank()) +
  scale_fill_manual(values=cbbPalette,
                    name = str_wrap('Plot average +/- 1 standard deviation', width = 15),
                    breaks = c('C', 'T'),
                    labels = c('control', "treatment"))+
  labs(x = '', y = 'Carbon Stored (tons/acre)')+
  facet_manual(~Stocks_Indicator, 
               design = design, 
               #scales = "free_y", 
               labeller = as_labeller(Var.Labels, 
                                      default=label_wrap_gen(20)))+
  expand_limits(y=0.1)#+ #limits the lowest value for the y axis so graphs with 0 values dont show 

}
```

```{r fig.cap=""}



```


### Dynamic map: all measured values

Use the map below to explore all measured values for each sampling location. Select a layer to visually explore values for a given indicator. Click a point to see all measured values at that point. 

```{r Dynamic map}

if ("bulk_density" %in% proj.indicators.SSC.stocks){
stockscolumns<-grep("_stocks$", proj.indicators.SSC, value = TRUE) #gather the names of the stocks columns
}

proj.indicators.nonbiomass<-proj.indicators.SSC[!proj.indicators.SSC %in% c("AHB", "HRB", "AWB", "WRB")] #CHECK! irrelevant for now but will be important later...get the rest of the project indicators that can be reported not as stocks...

if ("bulk_density" %in% proj.indicators.SSC.stocks) { #combine into one vector 
  dynamicmap.inds <- c(stockscolumns, proj.indicators.nonbiomass)
} else {
  dynamicmap.inds <- proj.indicators.nonbiomass
}

fixed_order <- c("org_c", "maoc", "poc", "bulk_density", "ph", "sand", "silt", "clay")
dynamicmap.inds <- c(
  intersect(fixed_order, dynamicmap.inds),           # fixed values in order
  setdiff(dynamicmap.inds, fixed_order)             # remaining values
) #getting values in the desired display order

PointData.projDYNAMIC<-PointLevel%>%
  select(sample_id, plot_type, all_of(dynamicmap.inds))


points<-points%>%
  rename(sample_id=name)%>%
  select(sample_id, geometry)
DataMap.proj<-left_join(points, PointData.projDYNAMIC, by="sample_id")

base_colors <- rainbow(length(dynamicmap.inds)) #create a rainbow palette from which to create color ramps

#define labels for legend and popups
Means.Pivot1<-Means.Pivot1%>%
  mutate(legend = paste0(Acronym,ifelse(is.na(Units), "", paste0(" ", Units))))
legends_names <- setNames(Means.Pivot1$legend, Means.Pivot1$Indicator) 

#create dataframe for point popups
df_forpopup <- DataMap.proj %>%
    mutate(across(any_of(dynamicmap.inds), ~round(.x,2)))%>%
  rename_with(~ legends_names[.x], .cols = any_of(names(legends_names)))
popupcols<-setdiff(names(df_forpopup), c("geometry", "plot_type", "plot_type"))


#color palette for plot borders
pal <- colorFactor(c("white","black"), c("T", "C"))
  
#create the leaflet map for plot borders
    DynamicMap<-leaflet()%>% #establishing the basemap first
      addProviderTiles(providers$Esri.WorldImagery) %>%
      addPolygons(data = st_zm(border),
              fillOpacity = 0,
              color = ~ pal(plot_type),
              opacity=1)%>%
      addLegend(
      pal = pal, 
      values = border$plot_type,
      title = "Plot Type",
      position = "bottomleft",
      labFormat = function(type, cuts, p) { 
      c("Treatment", "Control")[match(cuts, c("T", "C"))]
    })
  
    overlay_groups <- c()

  #start formatting legend values for the points
  for (i in seq_along(dynamicmap.inds)) {
    legend_name <- ifelse(dynamicmap.inds[i] %in% names(legends_names), 
                          legends_names[dynamicmap.inds[i]], 
                          dynamicmap.inds[i])
    
    #this prevents errors from being thrown when there are NAs 
    if (all(is.na(DataMap.proj[[dynamicmap.inds[i]]]))){domainz=c(0,1)
    }else{domainz=DataMap.proj[[dynamicmap.inds[i]]]}
    
    #establish color palette for points for different indicators -- a different raindbow color will be selected for each indicator
    pal<- colorNumeric(palette = colorRampPalette(c("white", base_colors[i]))(100), domain =domainz)

  #pipe the points into the map created for the plot borders
   DynamicMap<-  DynamicMap %>%
          addProviderTiles(providers$Esri.WorldImagery) %>%  # Add satellite imagery as the basemap
          addCircleMarkers(
            data = DataMap.proj,
            color = ~pal(get(dynamicmap.inds[i])),   # Apply the color scale to the SOC field
            opacity = 1,
            radius = 3,
            group = legend_name,
            label = DataMap.proj$sample_id,
            popup=popupTable(df_forpopup, zcol=popupcols,row.numbers = FALSE, feature.id = FALSE)
              )%>%
       addLegend(
            pal = pal, 
            values = DataMap.proj[[dynamicmap.inds[i]]],
            title = legend_name,
            group = legend_name
          )
   
   overlay_groups <- c(overlay_groups, legend_name)
  }
    
 DynamicMap <- DynamicMap %>%
  addLayersControl(
    overlayGroups = overlay_groups, # Groups to toggle
    options = layersControlOptions(collapsed = TRUE)
  )%>%hideGroup(setdiff(overlay_groups, "SOC %"))
   
    
DynamicMap

```

## Frequently Asked Questions

#### Why is monitoring soil organic carbon important?
Soil organic carbon makes up the majority of soil organic matter which provides a variety of services in agro-ecosystems. Soil organic carbon benefits soil organisms by creating a structured, porous environment. In turn, these soil organisms then increase fertility by cycling nutrients from waste materials, leading to higher productivity. Soils with higher levels of organic carbon have higher water holding capacity contributing to overall landscape resilience. Understanding how soil organic carbon changes in response to management practices across a variety of soils and climates, will help us prioritize lands for maximum conservation planting impact.

#### How can I interpret 1 ton of carbon per acre?
One ton of carbon per acre is equal to 3.67 metric tons of CO2 removed from the atmosphere, equivalent to 1 year of passenger car emissions. It is important to note that 1 ton of carbon per acre in our soil data is only to a 12 inch depth; much more carbon can be stored below that depth.  

#### As a land steward, how do I use all of this information?
The information in this report provides a baseline to measure the impact of future management changes. As time series data is not currently available, comparing across different areas of your own farm or ranch is most informative. Explore the dynamic map to gauge how different sites across the study area differ in key metrics. Additionally, our team is working towards a reporting structure that will allow landowners to compare their Ag-C data to other sites within the network, especially to other enrolled farms and ranches in their region. As our database grows, network-wide and regional comparisons will provide an increasingly detailed understanding of differing practice impacts across spatial scales. An online user dashboard allowing Ag-C land stewards to view and compare their results is planned for launch in Fall of 2025.

#### To measure the impact of conservation practices, I need to monitor change over time. How do I sample a second time?
Under the Ag-C framework, each conservation practice has its own recommended resampling interval that ranges from 1 year to 10 years, based on the expected impact of the practice over time^[Consult the [`r proj.protocol` Handbook](`r ifelse(proj.protocol=='Range-C', 'https://www.pointblue.org/?sdm_process_download=1&download_id=19991', 'https://www.pointblue.org/?sdm_process_download=1&download_id=20943')`) for more information about resampling intervals by conservation practice.]. Our team is always working to identify opportunities for continued monitoring for Ag-C participants. Contact our team if you're interested in pursuing support for future resampling events or if you have existing support for future monitoring and would like to continue participating in the Ag-C Monitoring Program.


## Conclusion
Thank you again for your participation in the Ag-C Monitoring Program. For more information about project design, further interpretation of results, or to access the raw data from your study site, please reach out to [RangeC\@pointblue.org](mailto:RangeC@pointblue.org) or [CropC\@pointblue.org](mailto:CropC@pointblue.org). Our team is happy to engage with additional questions or feedback. Your participation sharing data will launch new scientific understanding of conservation management and support improved incentive structures across the nation.